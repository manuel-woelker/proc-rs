var searchIndex = {};
searchIndex['proc'] = {"items":[[0,"","proc","",null,null],[3,"Statm","","Provides information about memory usage, as measured in pages.",null,null],[12,"size","","Total virtual memory size.",0,null],[12,"resident","","Resident non-swapped memory.",0,null],[12,"share","","Shared memory.",0,null],[12,"text","","Resident executable memory.",0,null],[12,"data","","Resident data and stack memory.",0,null],[3,"Status","","Provides status information for a process.",null,null],[12,"command","","Command run by this process.",1,null],[12,"state","","Current state of the process.",1,null],[12,"pid","","Thread Group ID (i.e., Process ID).",1,null],[12,"numa_gid","","NUMA group ID.",1,null],[12,"tid","","Thread ID.",1,null],[12,"ppid","","Process ID of parent process.",1,null],[12,"tracer_pid","","Process ID of the process tracing this process (0 if not being traced).",1,null],[12,"uid_real","","Real user ID.",1,null],[12,"uid_effective","","Effective user ID.",1,null],[12,"uid_saved","","Saved user ID.",1,null],[12,"uid_fs","","Filesystem user ID.",1,null],[12,"gid_real","","Real group ID.",1,null],[12,"gid_effective","","Effective group ID.",1,null],[12,"gid_saved","","Saved group ID.",1,null],[12,"gid_fs","","Filesystem group ID.",1,null],[12,"fd_allocated","","Number of file descriptor slots currently allocated.",1,null],[12,"groups","","Supplementary group list.",1,null],[12,"ns_pids","","Process IDs for each namespace which the process belongs to.",1,null],[12,"ns_tids","","Thread IDs for each namespace which the process belongs to.",1,null],[12,"ns_pgids","","Process group IDs for each namespace which the process belongs to.",1,null],[12,"ns_sids","","Session IDs of the process for each namespace to which it belongs.",1,null],[12,"vm_peak","","Peak virtual memory size (kB).",1,null],[12,"vm_size","","Virtual memory size (kB).",1,null],[12,"vm_locked","","Locked memory size (kB) (see mlock(3)).",1,null],[12,"vm_pin","","Pinned memory size (since Linux 3.2). These are pages that can't be moved because\nsomething needs to directly access physical memory.",1,null],[12,"vm_hwm","","Peak resident size (kB) (\"high water mark\").",1,null],[12,"vm_rss","","Resident set size.",1,null],[12,"vm_data","","Size of data segments (kB).",1,null],[12,"vm_stack","","Size of stack segments (kB).",1,null],[12,"vm_exe","","Size of text (executable) segments (kB).",1,null],[12,"vm_lib","","Shared library code size (kB).",1,null],[12,"vm_pte","","Page table entries size (since Linux 2.6.10).",1,null],[12,"vm_pmd","","Size of second-level page tables (since Linux 4.0).",1,null],[12,"vm_swap","","Swapped-out-virtual memory size (since Linux 2.6.34).",1,null],[12,"threads","","Number of threads in process containing this thread.",1,null],[12,"sig_queued","","The number of currently queued signals for this real user ID\n(see the description of RLIMIT_SIGPENDING in getrlimit(2)).",1,null],[12,"sig_queued_max","","The resource limit on the number of queued signals for this process.",1,null],[12,"sig_pending_thread","","Number of signals pending for the thread (see pthreads(7)).",1,null],[12,"sig_pending_process","","Number of signals pending for the process (see signal(7)).",1,null],[12,"sig_blocked","","Mask indicating signals being blocked.",1,null],[12,"sig_ignored","","Mask indicating signals being ignored.",1,null],[12,"sig_caught","","Mask indicating signals being caught.",1,null],[12,"cap_inherited","","Mask of capabilities enabled in inheritable sets (see capabilities(7)).",1,null],[12,"cap_permitted","","Mask of capabilities enabled in permitted sets.",1,null],[12,"cap_effective","","Mask of capabilities enabled in effective sets.",1,null],[12,"cap_bounding","","Capability Bounding set (since Linux 2.6.26).",1,null],[12,"seccomp","","Secure Computing mode of the process (since Linux 3.8, see seccomp(2)).\nThis field is provided only if the kernel was built with the\n`CONFIG_SECCOMP` kernel configuration option enabled.",1,null],[12,"cpus_allowed","","CPUs on which this process may run (since Linux 2.6.24, see cpuset(7)).",1,null],[12,"mems_allowed","","Memory nodes allowed to this process (since Linux 2.6.24, see cpuset(7)).",1,null],[12,"voluntary_ctxt_switches","","Number of voluntary context switches.",1,null],[12,"nonvoluntary_ctxt_switches","","Number of involuntary context switches.",1,null],[4,"SeccompMode","","The Secure Computing state of a process.",null,null],[13,"Disabled","","",2,null],[13,"Strict","","",2,null],[13,"Filter","","",2,null],[4,"State","","The state of a process.",null,null],[13,"Running","","Running.",3,null],[13,"Sleeping","","Sleeping in an interruptible wait.",3,null],[13,"Waiting","","Waiting in uninterruptible disk sleep.",3,null],[13,"Zombie","","Zombie.",3,null],[13,"Stopped","","Stopped (on a signal) or (before Linux 2.6.33) trace stopped.",3,null],[13,"TraceStopped","","trace stopped.",3,null],[13,"Paging","","Paging.",3,null],[13,"Dead","","Dead.",3,null],[13,"Wakekill","","Wakekill.",3,null],[13,"Waking","","Waking.",3,null],[13,"Parked","","Parked.",3,null],[5,"statm","","Returns memory status information for the process with the provided pid.",null,{"inputs":[{"name":"pid_t"}],"output":{"name":"result"}}],[5,"statm_self","","Returns memory status information for the current process.",null,{"inputs":[],"output":{"name":"result"}}],[5,"status","","Returns memory status information for the process with the provided pid.",null,{"inputs":[{"name":"pid_t"}],"output":{"name":"result"}}],[5,"status_self","","Returns memory status information for the current process.",null,{"inputs":[],"output":{"name":"result"}}],[11,"hash","","",0,null],[11,"eq","","",0,{"inputs":[{"name":"statm"},{"name":"statm"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"statm"},{"name":"statm"}],"output":{"name":"bool"}}],[11,"default","","",0,{"inputs":[{"name":"statm"}],"output":{"name":"statm"}}],[11,"fmt","","",0,{"inputs":[{"name":"statm"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",2,null],[11,"eq","","",2,{"inputs":[{"name":"seccompmode"},{"name":"seccompmode"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"seccompmode"},{"name":"seccompmode"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"seccompmode"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",2,{"inputs":[{"name":"seccompmode"}],"output":{"name":"seccompmode"}}],[11,"hash","","",1,null],[11,"eq","","",1,{"inputs":[{"name":"status"},{"name":"status"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"status"},{"name":"status"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"status"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",1,{"inputs":[{"name":"status"}],"output":{"name":"status"}}],[11,"hash","","",3,null],[11,"eq","","",3,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"state"},{"name":"state"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"state"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",3,{"inputs":[{"name":"state"}],"output":{"name":"state"}}]],"paths":[[3,"Statm"],[3,"Status"],[4,"SeccompMode"],[4,"State"]]};
searchIndex['nom'] = {"items":[[0,"","nom","Nom, eating data byte by byte",null,null],[3,"AccReader","","",null,null],[3,"FileProducer","","Can produce data from a file",null,null],[3,"MemProducer","","Can parse data from an already in memory byte array",null,null],[3,"ReadProducer","","Can produce data from a struct implementing Read",null,null],[3,"Stepper","","",null,null],[4,"ErrorCode","","",null,null],[13,"Tag","","",0,null],[13,"MapRes","","",0,null],[13,"MapOpt","","",0,null],[13,"Alt","","",0,null],[13,"IsNot","","",0,null],[13,"IsA","","",0,null],[13,"Filter","","",0,null],[13,"SeparatedList","","",0,null],[13,"SeparatedNonEmptyList","","",0,null],[13,"Many1","","",0,null],[13,"Count","","",0,null],[13,"TakeUntilAndConsume","","",0,null],[13,"TakeUntil","","",0,null],[13,"TakeUntilEitherAndConsume","","",0,null],[13,"TakeUntilEither","","",0,null],[13,"LengthValue","","",0,null],[13,"TagClosure","","",0,null],[13,"Alpha","","",0,null],[13,"Digit","","",0,null],[13,"AlphaNumeric","","",0,null],[13,"Space","","",0,null],[13,"MultiSpace","","",0,null],[13,"LengthValueFn","","",0,null],[13,"Eof","","",0,null],[13,"ExprOpt","","",0,null],[13,"ExprRes","","",0,null],[13,"CondReduce","","",0,null],[4,"Err","","",null,null],[13,"Code","","",1,null],[13,"Node","","",1,null],[13,"Position","","",1,null],[13,"NodePosition","","",1,null],[4,"Needed","","",null,null],[13,"Unknown","","",2,null],[13,"Size","","",2,null],[4,"IResult","","Holds the result of parsing functions",null,null],[13,"Done","","",3,null],[13,"Error","","",3,null],[13,"Incomplete","","",3,null],[4,"ProducerState","","Holds the data producer's current state",null,null],[13,"Eof","","",4,null],[13,"Continue","","",4,null],[13,"Data","","",4,null],[13,"ProducerError","","",4,null],[4,"StepperState","","",null,null],[13,"Eof","","",5,null],[13,"Value","","",5,null],[13,"ProducerError","","",5,null],[13,"Continue","","",5,null],[13,"ParserError","","",5,null],[4,"ConsumerState","","Holds the current state of the consumer",null,null],[13,"Await","","",6,null],[13,"Seek","","",6,null],[13,"Incomplete","","",6,null],[13,"ConsumerDone","","",6,null],[13,"ConsumerError","","",6,null],[5,"error_to_list","","",null,{"inputs":[{"name":"err"}],"output":{"name":"vec"}}],[5,"compare_error_paths","","",null,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[5,"add_error_pattern","","",null,{"inputs":[{"name":"hashmap"},{"name":"iresult"},{"name":"str"}],"output":{"name":"bool"}}],[5,"slice_to_offsets","","",null,null],[5,"prepare_errors","","",null,null],[5,"print_error","","",null,null],[5,"generate_colors","","",null,{"inputs":[{"name":"vec"}],"output":{"name":"hashmap"}}],[5,"code_from_offset","","",null,{"inputs":[{"name":"vec"},{"name":"usize"}],"output":{"name":"option"}}],[5,"reset_color","","",null,{"inputs":[{"name":"vec"}],"output":null}],[5,"write_color","","",null,{"inputs":[{"name":"vec"},{"name":"u8"}],"output":null}],[5,"print_codes","","",null,{"inputs":[{"name":"hashmap"},{"name":"hashmap"}],"output":{"name":"string"}}],[5,"print_offsets","","",null,null],[5,"tag_cl","","",null,null],[5,"print","","",null,{"inputs":[{"name":"t"}],"output":{"name":"iresult"}}],[5,"begin","","",null,null],[5,"not_line_ending","","",null,null],[5,"line_ending","","Recognizes a line feed",null,null],[5,"is_alphabetic","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_digit","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_alphanumeric","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"is_space","","",null,{"inputs":[{"name":"u8"}],"output":{"name":"bool"}}],[5,"alpha","","Recognizes lowercase and uppercase alphabetic characters: a-zA-Z",null,null],[5,"digit","","Recognizes numerical characters: 0-9",null,null],[5,"alphanumeric","","Recognizes numerical and alphabetic characters: 0-9a-zA-Z",null,null],[5,"space","","Recognizes spaces and tabs",null,null],[5,"multispace","","Recognizes spaces, tabs, carriage returns and line feeds",null,null],[5,"sized_buffer","","",null,null],[5,"length_value","","",null,null],[5,"be_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"be_u16","","Recognizes big endian unsigned 2 bytes integer",null,null],[5,"be_u32","","Recognizes big endian unsigned 4 bytes integer",null,null],[5,"be_u64","","Recognizes big endian unsigned 8 bytes integer",null,null],[5,"be_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"be_i16","","Recognizes big endian signed 2 bytes integer",null,null],[5,"be_i32","","Recognizes big endian signed 4 bytes integer",null,null],[5,"be_i64","","Recognizes big endian signed 8 bytes integer",null,null],[5,"le_u8","","Recognizes an unsigned 1 byte integer (equivalent to take!(1)",null,null],[5,"le_u16","","Recognizes little endian unsigned 2 bytes integer",null,null],[5,"le_u32","","Recognizes little endian unsigned 4 bytes integer",null,null],[5,"le_u64","","Recognizes little endian unsigned 8 bytes integer",null,null],[5,"le_i8","","Recognizes a signed 1 byte integer (equivalent to take!(1)",null,null],[5,"le_i16","","Recognizes little endian signed 2 bytes integer",null,null],[5,"le_i32","","Recognizes little endian signed 4 bytes integer",null,null],[5,"le_i64","","Recognizes little endian signed 8 bytes integer",null,null],[5,"be_f32","","Recognizes big endian 4 bytes floating point number",null,null],[5,"be_f64","","Recognizes big endian 8 bytes floating point number",null,null],[5,"eof","","Recognizes empty input buffers",null,null],[11,"clone","","",1,{"inputs":[{"name":"err"}],"output":{"name":"err"}}],[11,"eq","","",1,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"err"},{"name":"err"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"err"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"needed"}],"output":{"name":"needed"}}],[11,"eq","","",2,{"inputs":[{"name":"needed"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"needed"},{"name":"needed"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"needed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"iresult"}}],[11,"eq","","",3,{"inputs":[{"name":"iresult"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"iresult"},{"name":"iresult"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"iresult"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"is_done","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"is_err","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"is_incomplete","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"bool"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"remaining_input","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"output","","",3,{"inputs":[{"name":"iresult"}],"output":{"name":"option"}}],[11,"new","","",7,{"inputs":[{"name":"accreader"},{"name":"r"}],"output":{"name":"accreader"}}],[11,"with_capacity","","",7,{"inputs":[{"name":"accreader"},{"name":"usize"},{"name":"r"}],"output":{"name":"accreader"}}],[11,"get_ref","","Gets a reference to the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"get_mut","","Gets a mutable reference to the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"into_inner","","Unwraps this `AccReader`, returning the underlying reader.",7,{"inputs":[{"name":"accreader"}],"output":{"name":"r"}}],[11,"reset_buffer_position","","",7,{"inputs":[{"name":"accreader"}],"output":null}],[11,"current_slice","","",7,null],[11,"capacity","","",7,{"inputs":[{"name":"accreader"}],"output":{"name":"usize"}}],[11,"read","","",7,null],[11,"fill_buf","","",7,{"inputs":[{"name":"accreader"}],"output":{"name":"result"}}],[11,"consume","","",7,{"inputs":[{"name":"accreader"},{"name":"usize"}],"output":null}],[11,"eq","","",4,{"inputs":[{"name":"producerstate"},{"name":"producerstate"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"producerstate"},{"name":"producerstate"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"producerstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",8,{"inputs":[{"name":"fileproducer"},{"name":"str"},{"name":"usize"}],"output":{"name":"result"}}],[11,"produce","","",8,{"inputs":[{"name":"fileproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",8,{"inputs":[{"name":"fileproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"new","","",9,null],[11,"produce","","",9,{"inputs":[{"name":"memproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",9,{"inputs":[{"name":"memproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"new","","",10,{"inputs":[{"name":"readproducer"},{"name":"t"},{"name":"usize"}],"output":{"name":"readproducer"}}],[11,"produce","","",10,{"inputs":[{"name":"readproducer"}],"output":{"name":"producerstate"}}],[11,"seek","","",10,{"inputs":[{"name":"readproducer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[11,"eq","","",5,{"inputs":[{"name":"stepperstate"},{"name":"stepperstate"}],"output":{"name":"bool"}}],[11,"ne","","",5,{"inputs":[{"name":"stepperstate"},{"name":"stepperstate"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"stepperstate"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","",11,{"inputs":[{"name":"stepper"},{"name":"t"}],"output":{"name":"stepper"}}],[11,"step","","",11,{"inputs":[{"name":"stepper"},{"name":"f"}],"output":{"name":"stepperstate"}}],[11,"clone","","",6,{"inputs":[{"name":"consumerstate"}],"output":{"name":"consumerstate"}}],[11,"eq","","",6,{"inputs":[{"name":"consumerstate"},{"name":"consumerstate"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"consumerstate"},{"name":"consumerstate"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"consumerstate"},{"name":"formatter"}],"output":{"name":"result"}}],[8,"HexDisplay","","",null,null],[10,"offset","","",12,null],[10,"to_hex","","Converts the value of `self` to a hex value, returning the owned\nstring.",12,{"inputs":[{"name":"hexdisplay"},{"name":"usize"}],"output":{"name":"string"}}],[10,"to_hex_from","","",12,{"inputs":[{"name":"hexdisplay"},{"name":"usize"},{"name":"usize"}],"output":{"name":"string"}}],[8,"AsBytes","","",null,null],[10,"as_bytes","","",13,null],[8,"GetInput","","",null,null],[10,"remaining_input","","",14,{"inputs":[{"name":"getinput"}],"output":{"name":"option"}}],[8,"GetOutput","","",null,null],[10,"output","","",15,{"inputs":[{"name":"getoutput"}],"output":{"name":"option"}}],[8,"Producer","","A producer implements the produce method, currently working with u8 arrays",null,null],[10,"produce","","",16,{"inputs":[{"name":"producer"}],"output":{"name":"producerstate"}}],[10,"seek","","",16,{"inputs":[{"name":"producer"},{"name":"seekfrom"}],"output":{"name":"option"}}],[8,"Consumer","","Implement the consume method, taking a byte array as input and returning a consumer state",null,null],[10,"consume","","",17,null],[10,"failed","","",17,{"inputs":[{"name":"consumer"},{"name":"u32"}],"output":null}],[10,"end","","",17,{"inputs":[{"name":"consumer"}],"output":null}],[11,"run","","",17,{"inputs":[{"name":"consumer"},{"name":"producer"}],"output":null}],[14,"dbg!","","Prints a message if the parser fails",null,null],[14,"dbg_dmp!","","Prints a message and the input if the parser fails",null,null],[14,"closure!","","Wraps a parser in a closure",null,null],[14,"named!","","Makes a function from a parser combination",null,null],[14,"call!","","Used to wrap common expressions and function as macros",null,null],[14,"apply!","","",null,null],[14,"error!","","Prevents backtracking if the child parser fails",null,null],[14,"flat_map!","","`flat_map!(R -> IResult<R,S>, S -> IResult<S,T>) => R -> IResult<R, T>`",null,null],[14,"map!","","`map!(I -> IResult<I,O>, O -> P) => I -> IResult<I, P>`\nmaps a function on the result of a parser",null,null],[14,"map_impl!","","Internal parser, do not use directly",null,null],[14,"map_res!","","`map_res!(I -> IResult<I,O>, O -> Result<P>) => I -> IResult<I, P>`\nmaps a function returning a Result on the output of a parser",null,null],[14,"map_res_impl!","","Internal parser, do not use directly",null,null],[14,"map_opt!","","`map_res!(I -> IResult<I,O>, O -> Option<P>) => I -> IResult<I, P>`\nmaps a function returning an Option on the output of a parser",null,null],[14,"map_opt_impl!","","Internal parser, do not use directly",null,null],[14,"expr_res!","","`expr_res!(Result<E,O>) => I -> IResult<I, O>`\nevaluate an expression that returns a Result<T,E> and returns a IResult::Done(I,T) if Ok",null,null],[14,"expr_opt!","","`expr_opt!(Option<O>) => I -> IResult<I, O>`\nevaluate an expression that returns a Option<T> and returns a IResult::Done(I,T) if Ok",null,null],[14,"chain!","","`chain!(I->IResult<I,A> ~ I->IResult<I,B> ~ ... I->IResult<I,X> , || { return O } ) => I -> IResult<I, O>`\nchains parsers and assemble the results through a closure",null,null],[14,"chaining_parser!","","Internal parser, do not use directly",null,null],[14,"alt!","","`alt!(I -> IResult<I,O> | I -> IResult<I,O> | ... | I -> IResult<I,O> ) => I -> IResult<I, O>`\ntry a list of parser, return the result of the first successful one",null,null],[14,"alt_parser!","","Internal parser, do not use directly",null,null],[14,"opt!","","`opt!(I -> IResult<I,O>) => I -> IResult<I, Option<O>>`\nmake the underlying parser optional",null,null],[14,"opt_res!","","`opt_res!(I -> IResult<I,O>) => I -> IResult<I, Result<nom::Err,O>>`\nmake the underlying parser optional",null,null],[14,"cond!","","`cond!(bool, I -> IResult<I,O>) => I -> IResult<I, Option<O>>`\nConditional combinator",null,null],[14,"cond_reduce!","","`cond_reduce!(bool, I -> IResult<I,O>) => I -> IResult<I, O>`\nConditional combinator with error",null,null],[14,"peek!","","`peek!(I -> IResult<I,O>) => I -> IResult<I, O>`\nreturns a result without consuming the input",null,null],[14,"tap!","","`tap!(name: I -> IResult<I,O> => { block }) => I -> IResult<I, O>`\nallows access to the parser's result without affecting it",null,null],[14,"pair!","","`pair!(I -> IResult<I,O>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>`\npair(X,Y), returns (x,y)",null,null],[14,"separated_pair!","","`separated_pair!(I -> IResult<I,O>, I -> IResult<I, T>, I -> IResult<I,P>) => I -> IResult<I, (O,P)>`\nseparated_pair(X,sep,Y) returns (x,y)",null,null],[14,"separated_pair1!","","Internal parser, do not use directly",null,null],[14,"separated_pair2!","","Internal parser, do not use directly",null,null],[14,"preceded!","","`preceded!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, O>`\npreceded(opening, X) returns X",null,null],[14,"terminated!","","`terminated!(I -> IResult<I,O>, I -> IResult<I,T>) => I -> IResult<I, O>`\nterminated(X, closing) returns X",null,null],[14,"delimited!","","`delimited!(I -> IResult<I,T>, I -> IResult<I,O>, I -> IResult<I,U>) => I -> IResult<I, O>`\ndelimited(opening, X, closing) returns X",null,null],[14,"delimited1!","","Internal parser, do not use directly",null,null],[14,"delimited2!","","Internal parser, do not use directly",null,null],[14,"separated_list!","","`separated_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nseparated_list(sep, X) returns Vec<X>",null,null],[14,"separated_nonempty_list!","","`separated_nonempty_list!(I -> IResult<I,T>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nseparated_nonempty_list(sep, X) returns Vec<X>",null,null],[14,"many0!","","`many0!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nApplies the parser 0 or more times and returns the list of results in a Vec",null,null],[14,"many1!","","`many1!(I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\nApplies the parser 1 or more times and returns the list of results in a Vec",null,null],[14,"count!","","`count!(I -> IResult<I,O>, nb) => I -> IResult<I, Vec<O>>`\nApplies the child parser a specified number of times",null,null],[14,"count_fixed!","","`count_fixed!(I -> IResult<I,O>, nb) => I -> IResult<I, [O; nb]>`\nApplies the child parser a fixed number of times and returns a fixed size array",null,null],[14,"length_value!","","`length_value!(I -> IResult<I, nb>, I -> IResult<I,O>) => I -> IResult<I, Vec<O>>`\ngets a number from the first parser, then applies the second parser that many times",null,null],[14,"tag!","","`tag!(&[T]: nom::AsBytes) => &[T] -> IResult<&[T], &[T]>`\ndeclares a byte array as a suite to recognize",null,null],[14,"is_not!","","`is_not!(&[T:AsBytes]) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes that do not appear in the provided array",null,null],[14,"is_a!","","`is_a!(&[T]) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes that appear in the provided array",null,null],[14,"filter!","","`filter!(&[T] -> bool) => &[T] -> IResult<&[T], &[T]>`\nreturns the longest list of bytes until the provided function fails.",null,null],[14,"take!","","`take!(nb) => &[T] -> IResult<&[T], &[T]>`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"take_str!","","`take!(nb) => &[T] -> IResult<&[T], &str>`\nsame as take! but returning a &str",null,null],[14,"take_until_and_consume!","","`take_until_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>`\ngenerates a parser consuming bytes until the specified byte sequence is found",null,null],[14,"take_until!","","`take_until!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"take_until_either_and_consume!","","`take_until_either_and_consume!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"take_until_either!","","`take_until_either!(tag) => &[T] -> IResult<&[T], &[T]>`",null,null],[14,"bits!","","`bits!( parser ) => ( &[u8], (&[u8], usize) -> IResult<(&[u8], usize), T> ) -> IResult<&[u8], T>`\ntransforms its byte slice input in a bit stream for the underlying parsers",null,null],[14,"bits_impl!","","",null,null],[14,"take_bits!","","`take_bits!(type, nb) => ( (&[T], usize), U, usize) -> IResult<(&[T], usize), U>`\ngenerates a parser consuming the specified number of bytes",null,null],[14,"pusher!","","Prepares a parser function for a push pipeline",null,null],[14,"u16!","","if parameter is true, parse a big endian u16 integer,\notherwise a little endian u16 integer",null,null],[14,"u32!","","if parameter is true, parse a big endian u32 integer,\notherwise a little endian u32 integer",null,null],[14,"u64!","","if parameter is true, parse a big endian u64 integer,\notherwise a little endian u64 integer",null,null],[14,"i16!","","if parameter is true, parse a big endian i16 integer,\notherwise a little endian i16 integer",null,null],[14,"i32!","","if parameter is true, parse a big endian i32 integer,\notherwise a little endian i32 integer",null,null],[14,"i64!","","if parameter is true, parse a big endian i64 integer,\notherwise a little endian i64 integer",null,null],[11,"run","","",17,{"inputs":[{"name":"consumer"},{"name":"producer"}],"output":null}]],"paths":[[4,"ErrorCode"],[4,"Err"],[4,"Needed"],[4,"IResult"],[4,"ProducerState"],[4,"StepperState"],[4,"ConsumerState"],[3,"AccReader"],[3,"FileProducer"],[3,"MemProducer"],[3,"ReadProducer"],[3,"Stepper"],[8,"HexDisplay"],[8,"AsBytes"],[8,"GetInput"],[8,"GetOutput"],[8,"Producer"],[8,"Consumer"]]};
searchIndex['byteorder'] = {"items":[[0,"","byteorder","This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.",null,null],[4,"Error","","An error type for reading bytes.",null,null],[13,"UnexpectedEOF","","An unexpected EOF.",0,null],[13,"Io","","Any underlying IO error that occurs while reading bytes.",0,null],[4,"BigEndian","","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"from","std::io::error","",1,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"fmt","byteorder","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",0,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[6,"Result","","A short-hand for `result::Result<T, byteorder::Error>`.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i8"}],"output":{"name":"result"}}],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u16"}],"output":{"name":"result"}}],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i16"}],"output":{"name":"result"}}],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u64"}],"output":{"name":"result"}}],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i64"}],"output":{"name":"result"}}],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"f32"}],"output":{"name":"result"}}],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"f64"}],"output":{"name":"result"}}],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",4,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",4,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",4,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",4,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",4,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",4,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",4,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",4,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",4,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",4,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",4,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",4,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",4,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",4,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",4,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",4,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",4,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",4,null],[11,"read_u16","","",5,null],[11,"read_u32","","",5,null],[11,"read_u64","","",5,null],[11,"read_uint","","",5,null],[11,"write_u16","","",5,null],[11,"write_u32","","",5,null],[11,"write_u64","","",5,null],[11,"read_u16","","",6,null],[11,"read_u32","","",6,null],[11,"read_u64","","",6,null],[11,"read_uint","","",6,null],[11,"write_u16","","",6,null],[11,"write_u32","","",6,null],[11,"write_u64","","",6,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i8"}],"output":{"name":"result"}}],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u16"}],"output":{"name":"result"}}],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i16"}],"output":{"name":"result"}}],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u64"}],"output":{"name":"result"}}],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i64"}],"output":{"name":"result"}}],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"f32"}],"output":{"name":"result"}}],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"f64"}],"output":{"name":"result"}}]],"paths":[[4,"Error"],[3,"Error"],[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
initSearch(searchIndex);
